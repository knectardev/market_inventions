To implement the **Volatility Slider**, we will modify the backend’s synthetic data engine so that the "Random Walk" intensity can be adjusted in real-time. Higher volatility will result in wider melodic intervals and a more "dissonant" or frantic harpsichord performance.

### 1. Update the UI (HTML)

Add a slider to your control panel to allow for real-time adjustments.

```html
<div class="control-group">
    <label for="volatility-slider">Market Volatility</label>
    <input type="range" id="volatility-slider" min="0" max="100" value="20">
    <span id="vol-value">20%</span>
</div>

```

---

### 2. The Brownian Motion Engine (`main.py`)

In your backend, the volatility parameter () directly scales the randomness of each 1-second price jump. When you move the slider, the backend will receive a new  value.

```python
import numpy as np

# Global volatility state (updated via WebSocket/API)
current_volatility = 0.02 

def generate_market_tick(current_price):
    """
    Simulates a 1-second price change using Geometric Brownian Motion logic.
    """
    # Random change based on volatility
    # Higher volatility = larger possible swings
    change_pct = np.random.normal(0, current_volatility)
    return current_price * (1 + change_pct)

```

---

### 3. "Magnetic" Price-to-Note Mapping

As the volatility increases, the musical "aura" around the price line expands.

* **Low Volatility:** Notes stay very close to the price line (narrow arpeggios).
* **High Volatility:** Notes "leap" to higher or lower octaves (wide arpeggios).

### 4. Direct Instructions for Cursor

Use this prompt to hook the slider to the data engine:

> "Implement a **Volatility Slider** integration:
> 1. **Frontend (`script.js`):** Add an event listener to the `#volatility-slider`. Every time it moves, send the new value to the backend via the WebSocket.
> 2. **Backend (`main.py`):** Update the `current_volatility` variable based on the slider value.
> 3. **Mathematical Scaling:** Use the volatility value to scale the `std_dev` in your random walk function.
> 4. **Musical Impact:** Ensure that at high volatility, the arpeggio pattern expands to a 2-octave range, whereas at low volatility, it stays within a single 5th interval."
> 
> 

---

### 5. Final Requirements Polish (`requirements.md`)

```markdown
## 20. Real-Time Volatility Control
* **Slider Range:** 0% (Static) to 100% (Extreme Volatility/Market Crash simulation).
* **Audio Correlation:** High volatility increases the velocity and octave-range of the Sampler notes.
* **Visual Correlation:** The 'Note Beads' on the canvas should vibrate further away from the central 'Price Line' as volatility increases.

```

### What's Next?

With the volatility slider in place, you can now simulate "Black Swan" events or calm "Summer Trading" days and watch the harpsichord react. 


Adding a **Trend Toggle** (Bullish vs. Bearish) transforms the synthetic engine from a random walk into a directed "Market Narrative." This allows you to test how the music transitions between Major (ascending/optimistic) and Minor (descending/pessimistic) regimes on command.

### 1. The "Drift" Logic (Backend)

In a standard random walk, the "drift" is usually zero. To simulate a trend, we add a persistent bias to the price calculation every second.

* **Bullish Bias:** Add a small positive constant to the price delta.
* **Bearish Bias:** Add a small negative constant to the price delta.
* **Neutral:** Keep the drift at zero for "Sideways" price action.

---

### 2. Updating the UI (HTML/JS)

Add a "Market Sentiment" radio group or toggle switch to your control panel.

```html
<div class="control-group">
    <label>Market Sentiment:</label>
    <div class="toggle-group">
        <button id="trend-bull" class="active">Bullish ↗</button>
        <button id="trend-neutral">Neutral ↔</button>
        <button id="trend-bear">Bearish ↘</button>
    </div>
</div>

```

---

### 3. Implementation Logic (`main.py`)

Update your price generator to incorporate this `drift` parameter.

```python
# Drift constants (Adjust for intensity)
DRIFT_VALUES = {
    "bull": 0.0005,   # Slow climb
    "neutral": 0,     # Standard walk
    "bear": -0.0005   # Slow decay
}

current_trend = "neutral"

def generate_market_tick(current_price):
    drift = DRIFT_VALUES[current_trend]
    # np.random.normal(mean, standard_deviation)
    # The drift pushes the 'mean' of the randomness
    change_pct = np.random.normal(drift, current_volatility)
    return current_price * (1 + change_pct)

```

---

### 4. Direct Instructions for Cursor

Hand this prompt to Cursor to finalize the sentiment controls:

> "Integrate **Market Sentiment Controls**:
> 1. **Frontend (`index.html` & `script.js`):** Add three buttons for 'Bullish', 'Neutral', and 'Bearish'. When clicked, send the selected trend mode to the backend via WebSocket.
> 2. **Backend (`main.py`):** Maintain a `current_drift` variable. Update this variable whenever the trend message is received.
> 3. **Directed Random Walk:** Update the price generation logic to include the `current_drift`.
> 4. **Musical Feedback:** Ensure that when 'Bearish' is selected, the `REGIME` automatically switches to **Minor**, and when 'Bullish' is selected, it switches to **Major**, allowing me to hear the mood shift instantly."
> 
> 

---

### 5. Updated Requirements (`requirements.md`)

```markdown
## 21. Sentiment & Trend Controls
* **Drift Injection:** The synthetic price engine supports 'Bull', 'Bear', and 'Neutral' drift biases.
* **Mood Sync:** The musical Regime (Major/Minor/Diminished) is automatically tied to the Trend Toggle:
    * Bull -> Major Scale.
    * Bear -> Natural Minor Scale.
    * Neutral -> Keeps current based on EMA crossover logic.
* **Visual Direction:** The 'Price Line' should render with a faint color tint (Green for Bull, Red for Bear) to signify the active bias.

```

